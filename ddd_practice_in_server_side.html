<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"taccisum.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言什么是 DDDDDD 全称领域驱动设计，最初由 Eric Evans 提出，又细分为战略设计和战术设计两个层面。我们在此讨论的均属于战术设计范畴（即代码层面的设计）。 DDD 战术设计本质上是面向对象的一种设计方法。根本目的与面向对象一致，仍然是为了解决软件项目中不断增长的复杂性问题。 DDD 的适应范围比面向对象设计要狭窄，但据我们的实践，至少在服务端开发的领域，DDD 能很好地产生他的效用">
<meta property="og:type" content="article">
<meta property="og:title" content="DDD 战术设计之服务端落地实践">
<meta property="og:url" content="https://taccisum.github.io/ddd_practice_in_server_side.html">
<meta property="og:site_name" content="Taccisum&#39;s blog 😉">
<meta property="og:description" content="前言什么是 DDDDDD 全称领域驱动设计，最初由 Eric Evans 提出，又细分为战略设计和战术设计两个层面。我们在此讨论的均属于战术设计范畴（即代码层面的设计）。 DDD 战术设计本质上是面向对象的一种设计方法。根本目的与面向对象一致，仍然是为了解决软件项目中不断增长的复杂性问题。 DDD 的适应范围比面向对象设计要狭窄，但据我们的实践，至少在服务端开发的领域，DDD 能很好地产生他的效用">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-11-16T08:24:20.975Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DDD 战术设计之服务端落地实践">
<meta name="twitter:description" content="前言什么是 DDDDDD 全称领域驱动设计，最初由 Eric Evans 提出，又细分为战略设计和战术设计两个层面。我们在此讨论的均属于战术设计范畴（即代码层面的设计）。 DDD 战术设计本质上是面向对象的一种设计方法。根本目的与面向对象一致，仍然是为了解决软件项目中不断增长的复杂性问题。 DDD 的适应范围比面向对象设计要狭窄，但据我们的实践，至少在服务端开发的领域，DDD 能很好地产生他的效用">

<link rel="canonical" href="https://taccisum.github.io/ddd_practice_in_server_side.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>DDD 战术设计之服务端落地实践 | Taccisum's blog 😉</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Taccisum's blog 😉</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://taccisum.github.io/ddd_practice_in_server_side.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="taccisum">
      <meta itemprop="description" content="el psy congroo.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taccisum's blog 😉">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DDD 战术设计之服务端落地实践
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-16 16:04:22 / Modified: 16:24:20" itemprop="dateCreated datePublished" datetime="2021-11-16T16:04:22+08:00">2021-11-16</time>
            </span>

          
            <span id="/ddd_practice_in_server_side.html" class="post-meta-item leancloud_visitors" data-flag-title="DDD 战术设计之服务端落地实践" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/ddd_practice_in_server_side.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/ddd_practice_in_server_side.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="什么是-DDD"><a href="#什么是-DDD" class="headerlink" title="什么是 DDD"></a>什么是 DDD</h2><p>DDD 全称<strong>领域驱动设计</strong>，最初由 Eric Evans 提出，又细分为<strong>战略设计</strong>和<strong>战术设计</strong>两个层面。我们在此讨论的均属于战术设计范畴（即代码层面的设计）。</p>
<p>DDD 战术设计本质上是面向对象的一种设计方法。根本目的与面向对象一致，仍然是为了解决软件项目中不断增长的复杂性问题。</p>
<p>DDD 的适应范围比面向对象设计要狭窄，但据我们的实践，至少在服务端开发的领域，DDD 能很好地产生他的效用。</p>
<h3 id="DDD-能带来什么"><a href="#DDD-能带来什么" class="headerlink" title="DDD 能带来什么"></a>DDD 能带来什么</h3><ul>
<li>统一的术语，大大降低团队内的沟通成本</li>
<li>文档级可读性的代码</li>
<li>高度的代码复用性</li>
<li>高度的代码可测试性，进而带来稳定性</li>
<li>敏捷性，允许快速复用现有能力满足现实需求的变化</li>
</ul>
<h3 id="DDD-不能带来什么"><a href="#DDD-不能带来什么" class="headerlink" title="DDD 不能带来什么"></a>DDD 不能带来什么</h3><ul>
<li>高性能（滥用反而可能导致性能低下）</li>
<li>不出现 bug</li>
<li>一劳永逸的设计（架构应该是不断进化的）</li>
<li>……</li>
</ul>
<h2 id="DDD-落地"><a href="#DDD-落地" class="headerlink" title="DDD 落地"></a>DDD 落地</h2><p>DDD 一词起源于 Eric Evans 的一本书《领域驱动设计——软件核心复杂性应对之道》。可能许多同学应该都知道，并且多少看过这本书，但是大多数人都会觉得非常抽象、难以理解，看完后也不知道该如何将这些理论运用到实践中去。我个人的看法是，其实并不是这本书难以理解，而是这本书诞生于 C/S 架构流行的年代，里面许多案例其实是以 C/S 的角度去举例的。而我们现在流行的是 B/S 架构的软件，并且许多框架（如 Spring）几乎已经成为了服务端软件开发的必选项，如果只是照搬书上的那些例子，自然是无法很好地进行落地的。</p>
<p>以下谈及的内容是我在带领团队的过程中总结出来的一些 DDD 在服务端的落地实践，并不代表适合所有团队或所有技术栈。</p>
<h3 id="DDD-编写的代码所属层次"><a href="#DDD-编写的代码所属层次" class="headerlink" title="DDD 编写的代码所属层次"></a>DDD 编写的代码所属层次</h3><p>我们把 DDD 设计的相关代码放到 Domain 层，这一层是介于经典三层架构中 Service 与 DAO 层之间的特殊的一层，但严格意义上来说还是属于 Service 层（处理业务逻辑），可以想象成在原先的 Service 层上又划分了一层出来。</p>
<p>如下图所示</p>
<p>TODO::</p>
<p>示例<br>下面是我们在 JAVA 工程中采用的一个 DDD 包结构规范</p>
<p>TODO::</p>
<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><blockquote>
<p>以标识作为其基本定义的对象称为实体 - Eric Evans </p>
</blockquote>
<p>换句话说，即所有实体必须有一个唯一标识。</p>
<p>在我们的实践中，我们一般使用 id 字段作为实体的唯一标识。如果要区别某个对象是否一个实体，只要看他是否有 id 即可。</p>
<p>实体除了唯一标识外，往往还有很多其它属性，因此实体往往还会依赖一个仓储对象。有关仓储，会在后面提及。</p>
<p>一个典型的实体定义如下：<br>public class Project {<br>    private Long id;<br>    private ProjectRepository repo;</p>
<pre><code>public Project(Long id, ProjectRepository repo) {
    this.id = id;
    this.repo = repo;
}

public ProjectDO data() {
    return repo.selectById(this.id);
}
</code></pre><p>}</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>我们建议实体间的聚合采用软关联的方式，原因是在服务端开发中，这种有状态的对象朝生夕灭的情况非常常见（服务端要管理的对象非常多，不可能将所有实体都存在内存中，一般一个请求过来时会创建对象，请求结束后在下一次 GC 这个对象就会被销毁），而实体之间的关联可能是非常复杂的，每次使用时都构建一个完整的聚合非常不划算。</p>
<p>可以看看以下两种方式的区别：</p>
<h4 id="硬关联"><a href="#硬关联" class="headerlink" title="硬关联"></a>硬关联</h4><p>public class Project {<br>    private Long id;<br>    private List<application> apps;</application></p>
<pre><code>public Project(Long id, List&lt;Application&gt; apps) {
    this.id = id;
    this.apps = apps;
}

public List&lt;Application&gt; listApplications() {
    return this.apps;
}
</code></pre><p>}</p>
<h4 id="软关联"><a href="#软关联" class="headerlink" title="软关联"></a>软关联</h4><p>public class Project {<br>    private Long id;<br>    private ApplicationManager applicationManager;</p>
<pre><code>public Project(Long id, ApplicationManager applicationManager) {
    this.id = id;
    this.applicationManager = applicationManager;
}

public List&lt;Application&gt; listApplications() {
    return this.listAllApplicationId()
        .stream()
        .map(id -&gt; applicationManager.get(id))
        .collect(Collectors.toList())
}
</code></pre><p>}</p>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p>Q: 实体定义方法时是否可以使用值类型<br>A: 可以，但一般情况下不建议（特殊情况可以这样做，如考虑性能等问题的时候），因为这会导致方法的复用性大大降低。即使这样做了，也应该尽量返回较通用的值对象（如 DO），应避免使用 DTO, VO 等。</p>
<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>虽然在上面我们采用了软关联的方式建立实体之间的引用关系，但这并不代表要构建一个实体就非常简单了，原因是我们的实体除了依赖其它实体外，往往还需要依赖许多其它对象（如领域服务、Manager、仓储等），并且随着业务的变化，实体的依赖往往还会随之发生变化，如果还是通过传统的 new 方式去创建一个实体，会产生一些灾难性的问题：</p>
<ul>
<li>使用者必须清楚实体的创建细节，这会大大增加代码的复杂度</li>
<li>每当实体的构造方式发生变化时，不得不调整所有创建实体的代码逻辑以解决代码编译问题</li>
</ul>
<p>综上，工厂的概念依然有必要存在于服务端 DDD 中。</p>
<p>一个通用 Factory 的实现示例如下<br>public abstract class Factory {<br>    private static ProjectRepository projectRepository;</p>
<pre><code>public void setProjectRepository(ProjectRepository projectRepository) {
    this.projectRepository = projectRepository;
}

public Project newProject(Long id) {
    return new Project(id, projectRepository);
}
</code></pre><p>}</p>
<p>这种实现要求我们在应用启动的时候，通过钩子函数去为这个 Factory 把所有要用到的对象准备好，每当 Factory 需要的依赖变化时，都得调整这个钩子函数，稍显麻烦。现在服务端已经有许多非常成熟、方便的 IoC 框架（如 Spring），有条件的时候我们也会结合这些框架来实现 Factory。</p>
<h4 id="结合-Spring"><a href="#结合-Spring" class="headerlink" title="结合 Spring"></a>结合 Spring</h4><p>一个基于 Spring 实现的 Factory 如下<br>@Component<br>public class Factory {<br>    @Autowired<br>    private ProjectRepository projectRepository;</p>
<pre><code>public Project newProject(Long id) {
    return new Project(id, projectRepository);
}
</code></pre><p>}</p>
<h3 id="实体仓储（Repository）-TODO"><a href="#实体仓储（Repository）-TODO" class="headerlink" title="实体仓储（Repository） TODO::"></a>实体仓储（Repository） TODO::</h3><p>我们称其为 Manager，对应的其实是 Eric Evans 在书中提到的仓储（实体仓储）。为什么我们不使用仓储这个概念呢？原因是在服务端开发中本身就有仓储（数据仓储，也叫 DAO）这个概念。为了避免概念混淆，我们使用了另一个概念 Manager。</p>
<p>与 Eric Evans 的仓储概念定义一致，Manager 可以为使用者提供实体的创建、删除及条件查询操作。</p>
<p>Manager 往往还需要依赖仓储（查询持久化数据）及工厂（创建实体），并且可以发布事件。</p>
<h3 id="DAO-TODO"><a href="#DAO-TODO" class="headerlink" title="DAO TODO::"></a>DAO TODO::</h3><p>上面提到我们用 Manager 这个概念代替了原本 Evans 说的仓储概念，那么我们现在提及的仓储概念又是用来做什么的呢？</p>
<p>我们这里定义的仓储只负责与持久化数据打交道，即数据仓储。为什么不直接使用 ORM？是因为我们考虑到在现在流行的微服务架构中，服务拆分、沉淀是很经常发生的事。原先的大服务中，某个实体的数据可能是通过 ORM 去查询数据库得到的，而在拆分后，就变成了通过远程调用去获取了。为了解决这一问题，我们使用仓储这一概念使得持久化数据的操作过程变得透明，如果发生服务拆分沉淀，那么我们的领域层不需要做任何修改（只要概念的定义没有发生变化），只要调整仓储层的实现即可。</p>
<p>一些使用原则<br>● 实体不应该依赖属于其它实体的仓储<br>● 实体不应该绕过仓储直接访问数据（如直接操作 ORM 框架）</p>
<h3 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h3><p>领域服务用于处理一些在概念上不属于实体的操作，这些操作本质上往往是一些活动或行为，并且是无状态的。对于这类操作，将其强制进行归类会显得非常别扭，于是便引入了领域服务这一概念。需要明确的是，其与三层架构的 Service 层（应用服务）并不是一个概念。另外与 Evans 在书中提及的示例不同，为了避免混乱，我们一般不会为领域服务的类命名加上 Service 后缀。</p>
<p>示例<br>在某个管理主机的应用中，可以指定主机执行一些 Shell 命令，并且会将输出全部存储起来。但由于该操作执行频繁，因此输出记录会相当庞大，需要需要定时查找超过 15 天的执行记录并将其清理。</p>
<p>在以上背景中，存在几个实体：Host、Exec、ExecOutput。从我们的描述中可知，我们需要完成的这个操作无法归类到任何一个实体中，因此我们需要一个 ExecClearer 的领域服务来帮助我们完成该操作。</p>
<p>由于领域服务是无状态的，因此我们一般将其定义为单例<br>@Compoment<br>public class ExecClearer {<br>    private ExecManager execManager;</p>
<pre><code>public void clearOutDated(Integer interval) {
    // 以下实现代码与我们要说明的内容无关，可以无视
    OutDatedExecFinder finder = new OutDatedExecFinder(interval, execManager);
    while (finder.hasNext()) {
        finder.nextCollection()
            .stream().forEach(Exec::destroy);
    }
}
</code></pre><p>}</p>
<p>在其它地方，我们可以直接注入该领域服务，并使用<br>@Slf4j<br>@Component<br>public class ExecScheduledTask {</p>
<pre><code>@Autowired
private ExecClearer clearer;

@Value(&quot;${exec.output.interval.days:15}&quot;)
private Integer intervalDays;

@Scheduled(cron = &quot;0 0 0 * * ?&quot;)
public void deleteExecData() {
    log.info(&quot;starting clear exec data, intervalDays=&gt;{}&quot;, intervalDays);
    clearer.clearOutDated(intervalDays);
    log.info(&quot;clear exec data end&quot;);
}
</code></pre><p>}</p>
<h3 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h3><p>在我们的领域活动（实体、Manager 等操作）中会出现一系列的重要的事件，而这些事件的订阅者，往往需要对这些事件作出响应（例如，新增用户后，可能会触发一系列动作：发送欢迎信息、发放优惠券等等）。领域事件可以简单地理解为是发布订阅模式在 DDD 中的一种运用。</p>
<p>在我们的实践中，一般采用事件总线来快速地发布一个领域事件。</p>
<p>事件总线的接口定义一般如下<br>public interface EventBus {<br>    void post(Event event);<br>}</p>
<p>通过调用 EventBus.post() 方法，我们可以快速发布一个事件。</p>
<p>同时我们还会提供一个抽象类 AbstractEventPublisher </p>
<p>public class AbstractEventPublisher implements EventPublisher {<br>    private EventBus eventBus;</p>
<pre><code>public void setEventBus(EventBus eventBus) {
    this.eventBus = eventBus;
}

@Override
public void publish(Event event) {
    if (eventBus != null) {
        eventBus.post(event);
    } else {
        log.warn(&quot;event bus is null. event &quot; + event.getClass() + &quot; will not be published!&quot;);
    }
}
</code></pre><p>}</p>
<p>public interface EventPublisher {<br>    void publish(Event event);<br>}</p>
<p>这样我们可以让实体或 Manager 继承自 AbstractEventPublisher，其便有了发布事件的能力。至于如何订阅并处理这些事件，取决于 EventBus 的实现方式。举个例子，我们一般使用 Guava 的 EventBus，定义相关的 handler 并注册到 EventBus 中便可方便地处理这些事件</p>
<p>@Component<br>public class DomainEventBus extends EventBus implements InitializingBean {<br>    @Autowired<br>    private FooEventHandler fooEventHandler;</p>
<pre><code>@Override
public void afterPropertiesSet() {
    this.register(fooEventHandler);
}
</code></pre><p>}</p>
<p>@Component<br>@Slf4j<br>public class FooEventHandler implements DomainEventHandler {<br>    @Override<br>    @Subscribe<br>    public void listen(ProjectCreatEvent e) {<br>        // do something here…<br>    }<br>}</p>
<p>其它<br>TODO::<br>● ddd-support</p>
<h3 id="DDD-设计"><a href="#DDD-设计" class="headerlink" title="DDD 设计"></a>DDD 设计</h3><p>理解了 DDD 中的全部概念，也并不意味着就能做出一个好的设计了。</p>
<!-- DDD 设计中最重要的其实是实体的定义， -->
<p>DDD 的设计最重要的是做好以下几点：</p>
<ol>
<li>准确地定义实体</li>
<li>准确地定义实体应该有哪些方法</li>
<li>确立实体与实体之间的关系</li>
</ol>
<p>实体的设计其实是一个建模的过程。面向对象的设计方法本质就是将现实世界的对象关系以简化的形式提炼为模型。关于这一块，已经是一个更大的话题了，不在这里讨论。</p>
<p>案例工程<br>TODO::</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ddd_practice_in_java_server_side.html" rel="prev" title="DDD 战术设计之 Java 服务端落地简要方案探讨">
      <i class="fa fa-chevron-left"></i> DDD 战术设计之 Java 服务端落地简要方案探讨
    </a></div>
      <div class="post-nav-item">
    <a href="/undefined.html" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-DDD"><span class="nav-number">2.</span> <span class="nav-text">什么是 DDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD-能带来什么"><span class="nav-number">2.1.</span> <span class="nav-text">DDD 能带来什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD-不能带来什么"><span class="nav-number">2.2.</span> <span class="nav-text">DDD 不能带来什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD-落地"><span class="nav-number">3.</span> <span class="nav-text">DDD 落地</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD-编写的代码所属层次"><span class="nav-number">3.1.</span> <span class="nav-text">DDD 编写的代码所属层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实体"><span class="nav-number">3.2.</span> <span class="nav-text">实体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">3.3.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬关联"><span class="nav-number">3.3.1.</span> <span class="nav-text">硬关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软关联"><span class="nav-number">3.3.2.</span> <span class="nav-text">软关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FAQ"><span class="nav-number">3.3.3.</span> <span class="nav-text">FAQ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂"><span class="nav-number">3.4.</span> <span class="nav-text">工厂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结合-Spring"><span class="nav-number">3.4.1.</span> <span class="nav-text">结合 Spring</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实体仓储（Repository）-TODO"><span class="nav-number">3.5.</span> <span class="nav-text">实体仓储（Repository） TODO::</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DAO-TODO"><span class="nav-number">3.6.</span> <span class="nav-text">DAO TODO::</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#领域服务"><span class="nav-number">3.7.</span> <span class="nav-text">领域服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#领域事件"><span class="nav-number">3.8.</span> <span class="nav-text">领域事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD-设计"><span class="nav-number">3.9.</span> <span class="nav-text">DDD 设计</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="taccisum"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">taccisum</p>
  <div class="site-description" itemprop="description">el psy congroo.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/taccisum" title="GitHub → https://github.com/taccisum" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/taccisum@gmail.com" title="G-Mail → taccisum@gmail.com"><i class="fa fa-envelope fa-fw"></i>G-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">taccisum</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'q1GTC85aQcIvQIf3p9tWLTvW-gzGzoHsz',
      appKey     : 'OjWCd5UV1xcOyCEfsSzu9w7z',
      placeholder: "欢迎畅所欲言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
